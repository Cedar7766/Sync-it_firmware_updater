<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sync-it Firmware Uploader</title>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    h1 { margin-bottom: 0.5em; }
    #firmwareSelector { margin-right: 1em; }
    #status { margin-top: 1em; white-space: pre-line; }
    #fileInput { margin-top: 0.5em; display: block; }
    .muted { color: #666; }
  </style>
</head>
<body>
  <img src="Sync-it logo 4x3 transparent.png" alt="Sync-it Logo"
       style="max-width: 200px; display: block; margin-bottom: 1em;">
  <h1>Firmware Uploader</h1>

  <label for="firmwareSelector">Choose firmware from list:</label>
  <select id="firmwareSelector">
    <option>Loading...</option>
  </select>

  <br><br>
  <label for="fileInput">...or upload your own HEX file:</label>
  <input type="file" id="fileInput" accept=".hex">

  <br><br>
  <button id="uploadBtn">Connect, Read Serial ‚Üí Upload</button>
  <progress id="progress" value="0" max="100" style="display:block;width:300px;"></progress>
  <div id="status" class="muted"></div>

  <p id="instructions">
    Remove the top plate, plug in your Sync-it device via a mini USB cable, then click ‚ÄúConnect, Read Serial ‚Üí Upload‚Äù.<br>
    Make sure no other apps (like Serial Monitor) are using the port, select ‚ÄúCP2102 USB to UART Bridge Controller‚Äù.
  </p>

  <script src="avrbro.browser.js"></script>
  <script>
    const selector = document.getElementById('firmwareSelector');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const progress = document.getElementById('progress');

    let selectedFirmware = null;
    let userFile = null;

    // Load manifest.json
    fetch('firmware/manifest.json')
      .then(r => { if (!r.ok) throw new Error(`HTTP ${r.status}`); return r.json(); })
      .then(files => {
        selector.innerHTML = "";
        files.forEach(file => {
          const option = document.createElement('option');
          option.value = `firmware/${file}`;
          option.textContent = file;
          selector.appendChild(option);
        });
        selectedFirmware = selector.value;
      })
      .catch(err => {
        selector.innerHTML = "<option disabled>Error loading firmware list</option>";
        status.textContent = "‚ùå Could not load manifest.json: " + err.message;
      });

    selector.onchange = () => {
      selectedFirmware = selector.value;
      userFile = null;
      fileInput.value = null;
      status.textContent = `üìÅ Selected: ${selectedFirmware}`;
    };

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file && file.name.endsWith(".hex")) {
        userFile = file;
        selectedFirmware = null;
        selector.selectedIndex = -1;
        status.textContent = `üìÇ Selected file: ${file.name}`;
      } else {
        userFile = null;
        status.textContent = "‚ùå Please select a valid .hex file";
      }
    });

    async function getDeviceSerialNumber(port, timeoutMs = 12000) {
      // Read bytes and look for "UniqueID: XXXXX"
      const reader = port.readable.getReader();
      let textBuffer = "";
      const start = Date.now();
      const dec = new TextDecoder();

      try {
        while (Date.now() - start < timeoutMs) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value && value.length) {
            // Debug logging of raw bytes
            console.log("RX:", Array.from(value).map(b => b.toString(16).padStart(2,'0')).join(' '));
            textBuffer += dec.decode(value, { stream: true });

            const match = textBuffer.match(/UniqueID:\s*([0-9A-F]+)/i);
            if (match) return match[1];
          }
        }
        return null;
      } finally {
        reader.releaseLock();
      }
    }

    uploadBtn.onclick = async () => {
      status.textContent = "";
      progress.value = 0;

      if (!("serial" in navigator)) {
        status.textContent = "‚ùå Web Serial API not supported. Use Chrome/Edge over HTTPS.";
        return;
      }

      let port = null;
      let serial = null;

      try {
        // Ask user to pick the port once
        port = await navigator.serial.requestPort();

        // --- Reset first so the device boots fresh and will print the UniqueID after ~7s ---
        status.textContent = "üîÑ Resetting device to read UniqueID‚Ä¶";
        await port.open({ baudRate: 1200 });
        await new Promise(r => setTimeout(r, 250));
        await port.close();

        // Open at app baud to watch for the UniqueID
        await port.open({ baudRate: 57600 });
        status.textContent = "‚è≥ Waiting for device UniqueID (up to ~12s)‚Ä¶";
        const deviceId = await getDeviceSerialNumber(port, 12000);
        await port.close();

        if (deviceId) {
          status.textContent = `‚úÖ Detected device UniqueID: ${deviceId}`;
        } else {
          const proceed = confirm("‚ö†Ô∏è No UniqueID received.\nProceed with upload anyway?");
          if (!proceed) {
            return;
          }
          status.textContent = "Proceeding without UniqueID‚Ä¶";
        }

        // (Optional) Auto-match firmware by ID here, if you adopt a naming convention:
        // if (deviceId && selectedFirmware && !selectedFirmware.includes(deviceId)) {
        //   throw new Error(`Selected firmware does not match device ID ${deviceId}.`);
        // }

        // --- Now reset again to enter the bootloader for flashing ---
        status.textContent += "\nüîÑ Resetting into bootloader‚Ä¶";
        await port.open({ baudRate: 1200 });
        await new Promise(r => setTimeout(r, 250));
        await port.close();

        // Re-open at bootloader baud
        await port.open({ baudRate: 57600 });
        serial = new AvrSerial(port);
        await serial.open();
        const uploader = new STK500v1(serial);

        // Get firmware text
        let firmwareText = "";
        if (userFile) {
          firmwareText = await userFile.text();
        } else if (selectedFirmware) {
          firmwareText = await fetch(selectedFirmware).then(r => r.text());
        } else {
          throw new Error("No firmware selected or uploaded");
        }

        // Flash
        status.textContent += "\n‚¨ÜÔ∏è Uploading‚Ä¶";
        await uploader.flashHex(firmwareText, pct => (progress.value = pct));
        status.textContent += "\n‚úÖ Upload complete!";
      } catch (e) {
        status.textContent += "\n‚ùå Upload failed: " + e.message;
        console.error(e);
      } finally {
        try {
          if (serial) await serial.close();
          else if (port?.readable && port?.writable) await port.close();
        } catch (err) {
          console.warn("‚ö†Ô∏è Failed to fully close serial port:", err);
        }
      }
    };
  </script>
</body>
</html>
