<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>Sync-it Firmware Uploader</title>
  <style>
    body { font-family: sans-serif; padding: 2em; }
    h1 { margin-bottom: 0.5em; }
    #firmwareSelector { margin-right: 1em; }
    #status { margin-top: 1em; color: darkred; }
    #fileInput { margin-top: 0.5em; display: block; }
  </style>
</head>
<body>
  <img src="Sync-it logo 4x3 transparent.png" alt="Sync-it Logo"
       style="max-width: 200px; display: block; margin-bottom: 1em;">
  <h1>Firmware Uploader</h1>
  
  <label for="firmwareSelector">Choose firmware from list:</label>
  <select id="firmwareSelector">
    <option>Loading...</option>
  </select>
  <br><br>
  
  <label for="fileInput">...or upload your own HEX file:</label>
  <input type="file" id="fileInput" accept=".hex">
  
  <br><br>
  <button id="uploadBtn">Connect & Read Serial ‚Üí Upload</button>
  <progress id="progress" value="0" max="100" style="display: block; width: 300px;"></progress>
  <div id="status"></div>
  
  <p id="instructions">
    Remove the top plate, plug in your Sync-it device via a mini USB cable, then click "Connect & Upload".<br>
    Make sure no other apps (like Serial Monitor) are using the port, select 'CP2102 USB to UART Bridge Controller'
  </p>

  <script src="avrbro.browser.js"></script>
  <script>
    const selector = document.getElementById('firmwareSelector');
    const uploadBtn = document.getElementById('uploadBtn');
    const fileInput = document.getElementById('fileInput');
    const status = document.getElementById('status');
    const progress = document.getElementById('progress');

    let selectedFirmware = null;
    let userFile = null;

    // Load manifest.json
    fetch('firmware/manifest.json')
      .then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status}`);
        return r.json();
      })
      .then(files => {
        selector.innerHTML = "";
        files.forEach(file => {
          const option = document.createElement('option');
          option.value = `firmware/${file}`;
          option.textContent = file;
          selector.appendChild(option);
        });
        selectedFirmware = selector.value;
      })
      .catch(err => {
        selector.innerHTML = "<option disabled>Error loading firmware list</option>";
        status.textContent = "‚ùå Could not load manifest.json: " + err.message;
      });

    selector.onchange = () => {
      selectedFirmware = selector.value;
      userFile = null;
      fileInput.value = null;
      status.textContent = `üìÅ Selected: ${selectedFirmware}`;
    };

    fileInput.addEventListener("change", (e) => {
      const file = e.target.files[0];
      if (file && file.name.endsWith(".hex")) {
        userFile = file;
        selectedFirmware = null;
        selector.selectedIndex = -1;
        status.textContent = `üìÇ Selected file: ${file.name}`;
      } else {
        userFile = null;
        status.textContent = "‚ùå Please select a valid .hex file";
      }
    });

    async function getDeviceSerialNumber(port, timeoutMs = 8000) {
      const reader = port.readable.getReader();
      let textBuffer = "";
      const start = Date.now();
      try {
        while (Date.now() - start < timeoutMs) {
          const { value, done } = await reader.read();
          if (done) break;
          if (value) {
            textBuffer += new TextDecoder().decode(value);
            const match = textBuffer.match(/UniqueID:\s*([0-9A-F]+)/i);
            if (match) {
              return match[1];
            }
          }
        }
        return null;
      } finally {
        reader.releaseLock();
      }
    }

    uploadBtn.onclick = async () => {
      status.textContent = "";
      progress.value = 0;

      if (!("serial" in navigator)) {
        status.textContent = "‚ùå Web Serial API not supported. Use Chrome/Edge over HTTPS.";
        return;
      }

      let port = null;
      let serial = null;

      try {
        // 1Ô∏è‚É£ Step 1: Connect in app mode to read UniqueID
        port = await navigator.serial.requestPort();
        await port.open({ baudRate: 57600 });
        status.textContent = "‚è≥ Waiting for device UniqueID...";
        const deviceId = await getDeviceSerialNumber(port);
        await port.close();

        if (!deviceId) {
          throw new Error("Timed out waiting for UniqueID");
        }
        status.textContent = `‚úÖ Detected device UniqueID: ${deviceId}`;

        // (Optional) Match against firmware name here:
        // if (!selectedFirmware.includes(deviceId)) throw new Error("Firmware does not match device ID!");

        // 2Ô∏è‚É£ Step 2: Reset to bootloader
        await port.open({ baudRate: 1200 });
        await new Promise(r => setTimeout(r, 250));
        await port.close();

        // 3Ô∏è‚É£ Step 3: Reconnect in bootloader mode
        await port.open({ baudRate: 57600 });
        serial = new AvrSerial(port);
        await serial.open();
        const uploader = new STK500v1(serial);

        // 4Ô∏è‚É£ Step 4: Get firmware
        let firmwareText = "";
        if (userFile) {
          firmwareText = await userFile.text();
        } else if (selectedFirmware) {
          firmwareText = await fetch(selectedFirmware).then(r => r.text());
        } else {
          throw new Error("No firmware selected or uploaded");
        }

        // 5Ô∏è‚É£ Step 5: Flash firmware
        await uploader.flashHex(firmwareText, pct => progress.value = pct);
        status.textContent += "\n‚úÖ Upload complete!";
      } catch (e) {
        status.textContent = "‚ùå Upload failed: " + e.message;
        console.error(e);
      } finally {
        try {
          if (serial) await serial.close();
          else if (port?.readable && port?.writable) await port.close();
        } catch (err) {
          console.warn("‚ö†Ô∏è Failed to fully close serial port:", err);
        }
      }
    };
  </script>
</body>
</html>
